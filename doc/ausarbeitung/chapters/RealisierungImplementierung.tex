\chapter{Realisierung}
\section{Buchung}



\chapter{Implementierung}
\section{Buchungsdialog}
Dem Client soll es innerhalb der Anwendung ermöglicht werden über einen \glqq Buchungsdialog\grqq \thickspace eine Buchung abzuwickeln. Dieser Dialog teilt sich in mehrere Schritte auf. Im ersten Schritt muss der Nutzer ein Formular, bestehend aus Ankunfts-, Abreisedatum, Anzahl der Erwachsenen, Anzahl der Kinder und die Anzahl der Räume, ausfüllen. Will der Nutzer nun mit dem zweiten Schritt fortführen werden zuerst die Eingaben aus dem ersten Schritt auf Gültigkeit geprüft. Gültigkeit heißt in diesem Fall dass beispielsweise das Ankunftsdatum nicht in der Vergangenheit oder vor dem Abreisedatum liegen darf. Sind die Eingaben gültig wird eine HTTP-Anfrage an den Server geschickt mit dem Ziel alle zu der angegeben Aufenthaltszeit verfügbaren Zimmer als HTTP-Antwort zu erhalten. Im zweiten Schritt des Dialogs kann der Nutzer aus allen verfügbaren Zimmern die passenden für seinen Aufenthalt wählen. Bevor mit dem dritten Schritt fortgeführt wird, muss geprüft werden das genau so viele Zimmer, wie im ersten Schritt angegeben, ausgewählt wurden. Ist dies der Fall wird im nächsten Schritt mit einem Formular für alle persönlichen Daten des Nutzers fortgesetzt. Werden alle Felder des Formulars ordnungsgemäß ausgefüllt kann mit dem vierten und letzten Schritt fortgeführt werden. In diesem wird dem Nutzer eine Übersicht der angegebenen Daten bzw. der Buchung angezeigt und bietet dem Nutzer über ein Textfeld die Möglichkeit Extrawünsche an das Hotel zu äußern. Will der Nutzer die Buchung abschließen wird eine HTTP-POST-Anfrage an den Server, mit allen wichtigen Daten zu Erstellung der Buchung, versendet.

\section{Meine Buchung}
In der Webanwendung wird einem Nutzer unter dem Punkt \glqq Meine Buchung\grqq \thickspace ermöglicht Informationen über getätigte Buchungen abzufragen und diese Anzupassen. Hierfür muss in ein dafür bestimmtes Feld die Buchungsnummer des Clients eingegeben werden. Anschließend wird eine HTTP-GET-Anfrage mit dem Pfad \glqq /order/:id\grqq \thickspace an den Server gesendet, auf die der Server mit allen Informationen zu der Buchung antwortet, wenn die Buchungsnummer existiert. Im Anschluss wird dem Nutzer eine Übersicht mit den wichtigsten Informationen dargeboten und zusätzlich die Möglichkeit die Buchung zu stornieren oder die Reisedaten abzuändern.
\\
\\
Entscheidet sich der Client dazu die Buchung zu stornieren wird einem Fenster-Alert gefragt ob sich der Nutzer mit der Stornierung sicher ist. Bestätigt der Client die Löschung wird eine HTTP-DELETE-Anfrage mit dem Pfad \glqq /order/:id\grqq \thickspace an den Server gesendet. Ist die Stornierung erfolgreich wird eine Bestätigungs-E-Mail an den Nutzer gesendet.
\\
\\
Wird sich jedoch für die Änderung der Daten entschieden wird in einem neuen Fenster ein Formular zur Eingabe der neuen Reisedaten angezeigt. Werden dort die neuen Daten eingegeben und fortgefahren, sendet der Client eine HTTP-POST-Anfrage mit dem Pfad \glqq /order/dates\grqq \thickspace an den Server versendet.

\section{Buchung API}
Serverseitig wird eine API erstellt, die die clientseitige Kommunikation mit dem Server ermöglicht. Dafür wird ein express-Router mit verschiedenen Routen benötigt, die unter anderem das Erstellen, Löschen, Verändern und Abfragen von Buchungen abwickeln. Ein solcher Router wird mit express-Methode \glqq express.Router()\grqq \thinspace erstellt. Für jede Route wird es außerdem von Nöten sein, Zugriff auf die MongoDB-Datenbank zu besitzen. Mithilfe des MongoDB-Moduls wird dafür ein \glqq MongoClient\grqq \thinspace erzeugt, der die Adresse der MongoDB-Datenbank übergeben bekommt.

\subsection{Erstellen einer Buchung}
Für die Erstellung einer Buchung wird dem Router eine Route hinzugefügt, die auf einen HTTP-POST mit dem Pfad \glqq /order \grqq \thinspace reagiert. Innerhalb der Funktion die die Anfrage behandelt werden zu aller erst alle für die Buchung benötigten Informationen aus dem Request-Objekt in Konstanten gespeichert. Zu den benötigten Informationen gehören: Vorname, Nachname, E-Mail-Adresse, Telefonnummer, Wohnort (mit Ort, Straße, Hausnummer und PLZ), Ankunftsdatum, Abreisedatum und die Art von Zimmern die gebucht werden sollen. Anschließend wird geprüft ob die Konstanten gültig sind. Sollte eine nicht zulässig sein wird eine HTTP-Antwort mit dem Code 400 an den Client gesendet. Bestehen jedoch alle Konstanten die Prüfung, wird mit der Verbindung des MongoClients fortgeführt. Der Aufruf der \glqq connect\grqq- und daraufhin der \glqq db\grqq-Methode (mit dem Namen der gesuchten Datenbank) des bereits erstellten MongoClients, liefert ein Datenbank-Objekt mit dem nun einzelne Collections abgerufen werden können. 
\\
\\
Um einen neuen Nutzer anzulegen muss ein Collection-Objekt zur Anpassung der Collection die alle Nutzer enthält, mithilfe der \glqq collection\grqq -Methode des Datenbank-Objekts, erzeugt werden. Das Collection-Objekt erlaubt es mit der Methode \glqq insertOne(elemToInsert)\grqq \thinspace den neuen Nutzer mit allen dazugehörigen Informationen aus den gespeicherten Konstanten (Vorname, Nachname, Adresse, E-Mail, Telefonnummer) in die Collection einzufügen.
\\
\\
Im weiteren Verlauf werden die Collection mit allen Buchungen und die Collection mit allen Zimmern benötigt. Werden auf beiden Collections jeweils die Methoden \glqq find().toArray()\grqq \thinspace ohne Parameter aufgerufen, können alle Buchungen und Zimmer als Feld in jeweiligen Variablen abgelegt werden. Mithilfe des Algorithmus in \ref{alg:one} werden alle zu der angegebenen Ankunfts- und Abreisezeit verfügbaren Zimmer geliefert. Sind genug Zimmer mit den vom Client angegebenen Zimmertypen nicht vergeben werden für jeden zu buchenden Raum eine neue Buchung in die Buchungs-Collection eingefügt. Dabei besteht jede Buchung aus der ID des neuen Nutzers, der ID des verfügbaren Raums, des Ankunfts- und Abreisedatums.
\\
\\
Zuletzt wird per nodemailer eine Mail an die E-Mail-Adresse des Clients gesendet. Diese enthält die ID des angelegten Nutzers, welche später zu Änderung oder Stornierung der Buchung verwendet werden kann. Als Antwort erhält der Client eine HTTP-Antwort mit dem Status-Code 200 insofern keine Komplikationen auftreten.

\subsection{Ändern einer Buchung}
Um einem Nutzer zu ermöglichen die Daten einer bereits getätigten Buchung zu ändern, wird eine Route hinzugefügt, die auf einen HTTP-POST mit dem Pfad \glqq /order/dates\grqq \thinspace reagiert. Dafür müssen im ersten Schritt die Variablen mit den Werten aus dem HTTP-Body initialisiert und anschließend auf Gültigkeit überprüft werden. Die Werte bestehen aus der ID des Nutzers, das neue Ankunfts- und Abreisedatum. Sollte einer der Werte ungültig sein, wird eine HTTP-Antwort mit dem Status-Code 400 an den Client versendet. Sind sie jedoch gültig verbindet sich der MongoClient mit der Datenbank und fordert alle Buchungen an. Anschließend werden mithilfe der find-Methode einerseits alle Buchungen die mit der ID des Nutzers übereinstimmen und andererseits alle anderen Buchungen, in zwei verschiedenen Konstanten gespeichert. Aus den Raum-IDs der Buchungen des Nutzers werden alle Räume aus der Raum-Collection die diese IDs besitzen, in einem Feld gesammelt. Dadurch ist es möglich die in der Buchung gebuchten Zimmertypen in Variablen zu speichern, damit bei der Änderung der Daten auch wieder dieselben Zimmertypen gewählt werden. Wie schon in Kapitel 6.1.1 erklärt müssen auch hier alle Zimmer die während des neuen Ankunftsdatum bis zum neuen Abreisedatum verfügbar sind, ermittelt werden.
\\
\\
Sollte es nicht genügend Zimmer mit denselben Zimmertypen wie in der ursprünglichen Buchung geben, die während der neuen Daten verfügbar sind wird die bestehende Buchung nicht geändert und eine HTTP-Antwort mit dem Status-Code 400 an den Client gesendet. Sollte es jedoch genügend Zimmer geben wird die bisherigen Buchungen aus der \glqq reservation\grqq-Collection mithilfe der \glqq deleteMany\grqq-Methode gelöscht und anschließend neue Buchungen der gleichen Zimmertypen zu anderen Zeiten in diese Collection eingefügt. Ist der Ablauf problemlos wird der Status-Code 200 an den Client gesendet.

\subsection{Abfragen einer Buchung}
Um einem Nutzer zu ermöglichen die wichtigsten Daten wie beispielsweise das Ankunftsdatum, Abreisedatum, Anzahl der Nächte, der Gesamtpreis und die Anzahl der Räume einer bereits getätigten Buchung abzurufen, wird eine Route hinzugefügt, die auf einen HTTP-GET mit dem Pfad \glqq /order/:id\grqq \thinspace reagiert. Im ersten Schritt wird die ID der gesuchten Buchung aus den Parametern der HTTP-Anfrage in einer Konstante gespeichert und geprüft ob diese eine gültige MongoDB-ObjectId ist. Wenn die ID zulässig ist werden alle Reservierungen dessen Nutzer-ID mit dieser übereinstimmt in der MongoDB abgerufen. Mithilfe der Buchungen lassen sich das Ankunfts-, Abreisedatum und folglich auch die Anzahl der Nächte ermitteln. Außerdem werden wie schon in 6.1.1 und 6.1.2 alle Räume in Form eines Feldes benötigt. Der Gesamtpreis der Buchung wird dann wie folgt berechnet:
\begin{lstlisting}{Gesamtpreis}
	for (const room of rooms) {
		for (const reservation of reservations) {
			if (room._id.equals(reservation.room)) {
				totalPrice += room.price;
			}
		}
	}
    totalPrice *= totalNights;
\end{lstlisting}
Sind alle Daten zusammengetragen werden diese als JSON mit dem Status-Code 200 an den Client versendet.

\subsection{Löschen einer Buchung}
Für das Löschen einer Buchung wird eine Route benötigt, die auf ein HTTP-DELETE mit dem Pfad \glqq /order/:id\grqq \thickspace reagiert. Zuerst wird die ID der zu löschenden Buchung aus den Parametern der Anfrage auf Gültigkeit geprüft. Anschließend wird der Nutzer der diese ID besitzt, mithilfe der \glqq deleteOne\grqq-Methode der Nutzer-Collection aus dieser entfernt. Außerdem müssen alle Buchungen die diese ID besitzen durch die \glqq deleteMany\grqq-Methode aus der Buchungscollection entfernt werden. Treten keine Probleme bei der Löschung auf wird eine HTTP-Antwort mit dem Status-Code 200 an den Client gesendet.

\section{Bewerbungsformular}
Unter dem Punkt Karriere ist es innerhalb der Anwendung möglich über ein eigens dafür erstelltes Formular eine Bewerbung an den Betreiber der Webanwendung zu senden. Hier soll es unter anderem ermöglicht werden, den Lebenslauf und die Bewerbung als PDF hochzuladen. Beim Absenden des Formulars wird die HTTP-Methode POST mit dem Pfad \glqq \thickspace verwendet. Serverseitig wird eine passende express-Route definiert, in welcher mithilfe von Formidable der Dateien-Upload gewährleistet wird.
\\
\\
Im ersten Schritt wird in der express-Route das eingehende Formular durch \newline \glqq const form = new formidable.IncomingForm()\grqq \thickspace in einer Konstante gespeichert. Anschließend können die Attribute des Formulars zugewiesen werden. In diesem Fall wird festgelegt das mehrere Dateien akzeptiert werden, das jede Datei maximal 5MB groß sein darf und in welchem Ordner die Dateien abgelegt werden. Danach wird folgende Methode aufgerufen: \glqq form.parse(request, CALLBACK)\grqq \thickspace, wobei CALLBACK eine Funktion mit allen Feldern und Dateien des Formulars als Parameter ist. In dieser Funktion wird unter anderem definiert wie mit einem Error umgegangen werden soll. Sollte kein Error auftreten wird mit dem speichern der hochgeladenen Dateien fortgefahren. Dafür wird im ersten Schritt der Dateien-Parameter in eine JSON umgewandelt und alle Schlüssel dieser in einem Feld gespeichert. In einer for-Schleife wird dann durch alle Schlüssel iteriert und unter anderem geprüft ob jede Datei größer als 0MB ist ein gültiges Format besitzt. Sollte die Größe einer der Dateien, 0MB entsprechen wird diese aus dem Dateisystem entfernt und Dateien im falschen Formate sorgen dafür das der Server dem Client mit dem Status-Code 400 antwortet. Ist die Datei gültig wird sie umbenannt und der neue Pfad in einem neuen Feld gespeichert. Anschließend werden die Dateien aus dem neuen Feld per nodemailer an eine E-Mail angehängt und dem Betreiber der Webanwendung gesendet.

\section{Dreidimensionale Zimmer}
Zunächst wird ein Canvas-Element in der HTML Datei benötigt. Diese Element bleibt leer und dient nur als Zeichenfläche für die mit JavaScript bzw. Three.js erstellten Objekte. Als nächstes wird ein Renderer verwedet, der das Ergebnis am Ende in dem Canvas-Element rendert, dazu wird ein Instanz des Renderes wie folgt erzeugt: renderer = new THREE.WebGLRenderer(). Des Weiteren werden zwei weitere Objekte erzeugt, das Szeneobjekt let scene = new THREE.Scene() und das Kameraobjekt let camera = new THREE.PrespectiveCamera(). Diese werden miteinander verbunden in dem sie als Argumente an die Methode renderer.render(scene, camera) übergeben wird. Allerdings müsste diese Methode nach jedem gerenderten Frame aufgerufen werden. Damit es automatisch geschieht eignet sich eine gesonderte namens animate(), in der die vorher erwähnte Funktion einmal aufgerufen wird an den renderer wie folgt zu übergeben: renderer.setAnimationLoop(animate).
\newpage
Das Kameraobjekt hat folgende Parameter:
\begin{enumerate}
	\item \textbf{Field Of View (engl. Sichtfeld)}, hier liegt ein passender Wert zwischen 40-80 Grad.
	\item \textbf{Aspect ratio (engl. Seitenverhältnis)}, mit window.innerWidth / window.innerHeight wird die gerenderte Szene in Vollbild Modus angezeigt und somit die komplette Fläche des Bildschirmes genutzt.  
	\item \textbf{Near (engl. Nahe)}, hier eignet sich ein geringer Wert zwichen 0.1-1, denn jeder Wert darunter wird abgeschnitten. Dieser Parameter besitzt keine Einheit. 
	\item \textbf{Far (engl. Weit)}, hier eignet sich ein hoher Wert wie 1000, denn jeder höhere Wert wird abgeschnitten. Dieser Parameter besitzt keine Einheit.
\end{enumerate}
Das Kameraobjekt befindet standardmäßig an der Position x = 0, y = 0, z = 0. Diese lässt sich aber beliebig mit der Methode \glqq camera.position.set()\grqq \thickspace ändern. Die Instanz der OrbitControls: orbit = new OrbitControls(camera, renderer.domElement), ermögicht den Nutzern die Kamera beliebig zu drehen. Das Orbitobjekt nimmt ein Kameraobjekt und renderer.domElement als Parameter. Damit die Position der Kamera nach einer Mausbewegung aktualisiert wird, wird die Methode orbit.update() aufgerufen.
\\
\\
Die im Projekt verwendeten .hdr-Bilder bieten realistische Beleuchtung, Schatten und Spiegelung. Von daher war es nötig eine Instanz des RGBELoaders: loader = new RGBELoader(), zu erzeugen. Die Methode loader.load nimmt zwei Parameter, der relative Pfad des .hdr-Bilds und eine Rückruffunktion, die eine Textur als Argument hat. Die Textur bzw. das Bild wird dann als Hintergrund der Szene festgelegt.
